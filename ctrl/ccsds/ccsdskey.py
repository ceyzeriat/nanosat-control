#!/usr/bin/env python
# -*- coding: utf-8 -*-


from . import ccsdsexception
from ..utils import core


__all__ = ['CCSDSKey']


class CCSDSKey(object):
    def __init__(self, name, dic=None, start=None, l=1, fctunpack=None,
                 fctpack=None, dic_force=None, non_db_dic=False):
        """
        Dictionary of keys to perform easy extraction from a bits sequence.
        
        Args:
        * name (str): the name of the dictionary, for referencing
        * dic (dict): dictionary of possible values
        * start (int): start-position in bit from the beginning of the
          primary header, or whatever reference you decided
        * l (int): length of the strip of bits
        * fctunpack (callable) [optional]: function to apply to the bits to
          get the value. Shall remain ``None`` if ``dic`` is provided
        * fctpack (callable) [optional]: reverse function of ``fctunpack``
          Shall remain ``None`` if ``dic`` is provided
        """
        self.name = str(name)
        self._fctunpack = fctunpack if callable(fctunpack) else None
        self._fctpack = fctpack if callable(fctpack) else None
        self.isdic = (dic is not None)
        self.dic = dict(dic) if self.isdic else None
        if self.isdic:
            if self._fctunpack is not None or self._fctpack is not None:
                raise ccsdsexception.BadDefinition(name=self.name)
        else:
            if self._fctunpack is None and self._fctpack is None:
                raise ccsdsexception.BadDefinition(name=self.name)
        self.can_unpack = (self._fctunpack is not None or self.isdic)
        self.can_pack = (self._fctpack is not None or self.isdic)
        self.relative_only = False
        self.len = int(l)
        # just the length is provided
        if start is None:
            self.start = 0
            self.end = self.len
            self.relative_only = True
        elif start is not None:
            self.start = int(start)
            self.end = self.start + self.len
        self.cut = slice(self.start, self.end)
        self.cut_rel = slice(0, self.len)
        self.dic_force = dic_force
        self.non_db_dic = bool(non_db_dic)

    def __str__(self):
        return "{}: <{}>".format(self.name, self.cut)

    __repr__ = __str__

    def cut_offset(self, offset):
        """
        Returns the slice with an offset in position

        Args:
        * offset (int): the offset
        """
        offset = int(offset)
        if self.start + offset < 0:
            raise ccsdsexception.CantApplyOffset(   name=self.name,
                                                    start=self.start,
                                                    offset=offset)
        else:
            return slice(self.start + offset, self.end + offset)
    
    def __getitem__(self, key):
        if not self.isdic:
            raise ccsdsexception.NoDic(name=self.name)
        if key in self.dic.keys():
            return self.dic[key]
        elif str(key) in self.dic.keys():
            return self.dic[str(key)]
        else:
            try:
                return self.dic[int(key)]
            except:
                raise ccsdsexception.NoSuchKey(name=self.name, key=key)

    def unpack(self, packet, rel=False, raw=False, offset=None, **kwargs):
        """
        Grabs the slice of relevant bits in the packet and returns
        the corresponding key or applies the unpack function

        Args:
        * packet (str): the packet, either chain of '0' and '1' or hex
          depending how ``start`` and ``l`` were defined
        * rel (bool): if ``False`` follows ``start``, if ``True``
          grabs the bits from the position 0 (or ``offset``) of the
          packet provided. Ignored if ``offset`` is not ``None``
        * raw (bool): if ``True``, returns the raw bit sequence
        * offset (int) [optional]: offset to apply to the slice

        Kwargs:
        * Passed on to ``fctunpack`` if applicable
        """
        if not self.can_unpack and not raw:
            raise ccsdsexception.NoUnpack(name=self.name)
        if not rel and self.relative_only and offset is None:
            raise ccsdsexception.NoAbsGrab(name=self.name)
        if offset is not None:
            bits = packet[self.cut_offset(offset=int(offset))]
        else:
            bits = packet[self.cut_rel if rel else self.cut]
        if len(bits) != self.len:
            raise ccsdsexception.GrabFail(name=self.name, l=self.len)
        if raw:
            return bits
        elif self._fctunpack is None:
            return self._dic_rev(core.reverse_if_little_endian(bits))
        else:
            return self._fctunpack(bits, **kwargs)

    def pack(self, value, raw=False, pad=None, **kwargs):
        """
        Give a value, returns the sequence of bits from dic or
        generated by fctpack, and finally pads it if necessary

        Args:
        * value: the value to convert to bits
        * raw (bool): if ``True``, a simple int2bin transform is applied
          to the input value, with a padding to the key length,
          unless ``pad`` is provided
        * pad (int or None) [optional]: the padding length to
          apply, or default ``None`` pads to key length .

        Kwargs:
        * Passed on to and ``fctpack`` if applicable
        """
        if self.isdic and self.dic_force is not None:
            value = self.dic_force
        if not self.can_pack and not raw:
            raise ccsdsexception.NoPack(name=self.name)
        pad = self.len if pad is None else int(pad)
        if raw:
            return core.int2bin(value, pad=pad)
        elif self._fctpack is None:
            return core.reverse_if_little_endian(self[value])
        else:
            return core.padit(self._fctpack(value, pad=pad, **kwargs),
                              l=pad, ch='0')

    def _dic_rev(self, value):
        """
        Performs the reverse search in the dictionary: given a
        value, it will return the corresponding key

        Args:
        * value: the value to search in ``dic``
        """
        found = False
        for k, v in self.dic.items():
            if v == value:
                found = True
            elif str(v) == str(value):
                found = True
            else:
                try:
                    if int(v) == int(value):
                        found = True
                except:
                    pass
            if found:
                return k
        else:
            raise ccsdsexception.NoSuchValue(name=self.name, value=value)
